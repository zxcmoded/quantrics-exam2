{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { DefaultHttpClient } from \"./HttpClient\";\nimport { LogLevel } from \"./ILogger\";\nimport { HttpTransportType, TransferFormat } from \"./ITransport\";\nimport { LongPollingTransport } from \"./LongPollingTransport\";\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\nimport { Arg, createLogger } from \"./Utils\";\nimport { WebSocketTransport } from \"./WebSocketTransport\";\nvar MAX_REDIRECTS = 100;\n/** @private */\n\nvar HttpConnection =\n/** @class */\nfunction () {\n  function HttpConnection(url, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.features = {};\n    Arg.isRequired(url, \"url\");\n    this.logger = createLogger(options.logger);\n    this.baseUrl = this.resolveUrl(url);\n    options = options || {};\n\n    options.accessTokenFactory = options.accessTokenFactory || function () {\n      return null;\n    };\n\n    options.logMessageContent = options.logMessageContent || false;\n    this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);\n    this.connectionState = 2\n    /* Disconnected */\n    ;\n    this.options = options;\n  }\n\n  HttpConnection.prototype.start = function (transferFormat) {\n    transferFormat = transferFormat || TransferFormat.Binary;\n    Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n    this.logger.log(LogLevel.Debug, \"Starting connection with transfer format '\" + TransferFormat[transferFormat] + \"'.\");\n\n    if (this.connectionState !== 2\n    /* Disconnected */\n    ) {\n      return Promise.reject(new Error(\"Cannot start a connection that is not in the 'Disconnected' state.\"));\n    }\n\n    this.connectionState = 0\n    /* Connecting */\n    ;\n    this.startPromise = this.startInternal(transferFormat);\n    return this.startPromise;\n  };\n\n  HttpConnection.prototype.send = function (data) {\n    if (this.connectionState !== 1\n    /* Connected */\n    ) {\n      throw new Error(\"Cannot send data if the connection is not in the 'Connected' State.\");\n    }\n\n    return this.transport.send(data);\n  };\n\n  HttpConnection.prototype.stop = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.connectionState = 2\n            /* Disconnected */\n            ;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.startPromise];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            if (!this.transport) return [3\n            /*break*/\n            , 6];\n            this.stopError = error;\n            return [4\n            /*yield*/\n            , this.transport.stop()];\n\n          case 5:\n            _a.sent();\n\n            this.transport = null;\n            _a.label = 6;\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.startInternal = function (transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var url, negotiateResponse, redirects, _loop_1, this_1, state_1, e_2;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            url = this.baseUrl;\n            this.accessTokenFactory = this.options.accessTokenFactory;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 12,, 13]);\n\n            if (!this.options.skipNegotiation) return [3\n            /*break*/\n            , 5];\n            if (!(this.options.transport === HttpTransportType.WebSockets)) return [3\n            /*break*/\n            , 3]; // No need to add a connection ID in this case\n\n            this.transport = this.constructTransport(HttpTransportType.WebSockets); // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n\n            return [4\n            /*yield*/\n            , this.transport.connect(url, transferFormat)];\n\n          case 2:\n            // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            throw Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n\n          case 4:\n            return [3\n            /*break*/\n            , 11];\n\n          case 5:\n            negotiateResponse = null;\n            redirects = 0;\n\n            _loop_1 = function () {\n              var accessToken_1;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , this_1.getNegotiationResponse(url)];\n\n                  case 1:\n                    negotiateResponse = _a.sent(); // the user tries to stop the connection when it is being started\n\n                    if (this_1.connectionState === 2\n                    /* Disconnected */\n                    ) {\n                      return [2\n                      /*return*/\n                      , {\n                        value: void 0\n                      }];\n                    }\n\n                    if (negotiateResponse.url) {\n                      url = negotiateResponse.url;\n                    }\n\n                    if (negotiateResponse.accessToken) {\n                      accessToken_1 = negotiateResponse.accessToken;\n\n                      this_1.accessTokenFactory = function () {\n                        return accessToken_1;\n                      };\n                    }\n\n                    redirects++;\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            };\n\n            this_1 = this;\n            _a.label = 6;\n\n          case 6:\n            return [5\n            /*yield**/\n            , _loop_1()];\n\n          case 7:\n            state_1 = _a.sent();\n            if (typeof state_1 === \"object\") return [2\n            /*return*/\n            , state_1.value];\n            _a.label = 8;\n\n          case 8:\n            if (negotiateResponse.url && redirects < MAX_REDIRECTS) return [3\n            /*break*/\n            , 6];\n            _a.label = 9;\n\n          case 9:\n            if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\n              throw Error(\"Negotiate redirection limit exceeded.\");\n            }\n\n            return [4\n            /*yield*/\n            , this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];\n\n          case 10:\n            _a.sent();\n\n            _a.label = 11;\n\n          case 11:\n            if (this.transport instanceof LongPollingTransport) {\n              this.features.inherentKeepAlive = true;\n            }\n\n            this.transport.onreceive = this.onreceive;\n\n            this.transport.onclose = function (e) {\n              return _this.stopConnection(e);\n            }; // only change the state if we were connecting to not overwrite\n            // the state if the connection is already marked as Disconnected\n\n\n            this.changeState(0\n            /* Connecting */\n            , 1\n            /* Connected */\n            );\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            e_2 = _a.sent();\n            this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e_2);\n            this.connectionState = 2\n            /* Disconnected */\n            ;\n            this.transport = null;\n            throw e_2;\n\n          case 13:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.getNegotiationResponse = function (url) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, token, headers, negotiateUrl, response, e_3;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.accessTokenFactory()];\n\n          case 1:\n            token = _b.sent();\n\n            if (token) {\n              headers = (_a = {}, _a[\"Authorization\"] = \"Bearer \" + token, _a);\n            }\n\n            negotiateUrl = this.resolveNegotiateUrl(url);\n            this.logger.log(LogLevel.Debug, \"Sending negotiation request: \" + negotiateUrl);\n            _b.label = 2;\n\n          case 2:\n            _b.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.httpClient.post(negotiateUrl, {\n              content: \"\",\n              headers: headers\n            })];\n\n          case 3:\n            response = _b.sent();\n\n            if (response.statusCode !== 200) {\n              throw Error(\"Unexpected status code returned from negotiate \" + response.statusCode);\n            }\n\n            return [2\n            /*return*/\n            , JSON.parse(response.content)];\n\n          case 4:\n            e_3 = _b.sent();\n            this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e_3);\n            throw e_3;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.createConnectUrl = function (url, connectionId) {\n    return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + (\"id=\" + connectionId);\n  };\n\n  HttpConnection.prototype.createTransport = function (url, requestedTransport, negotiateResponse, requestedTransferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var connectUrl, transports, _i, transports_1, endpoint, transport, ex_1;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);\n            if (!this.isITransport(requestedTransport)) return [3\n            /*break*/\n            , 2];\n            this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n            this.transport = requestedTransport;\n            return [4\n            /*yield*/\n            , this.transport.connect(connectUrl, requestedTransferFormat)];\n\n          case 1:\n            _a.sent(); // only change the state if we were connecting to not overwrite\n            // the state if the connection is already marked as Disconnected\n\n\n            this.changeState(0\n            /* Connecting */\n            , 1\n            /* Connected */\n            );\n            return [2\n            /*return*/\n            ];\n\n          case 2:\n            transports = negotiateResponse.availableTransports;\n            _i = 0, transports_1 = transports;\n            _a.label = 3;\n\n          case 3:\n            if (!(_i < transports_1.length)) return [3\n            /*break*/\n            , 9];\n            endpoint = transports_1[_i];\n            this.connectionState = 0\n            /* Connecting */\n            ;\n            transport = this.resolveTransport(endpoint, requestedTransport, requestedTransferFormat);\n            if (!(typeof transport === \"number\")) return [3\n            /*break*/\n            , 8];\n            this.transport = this.constructTransport(transport);\n            if (!(negotiateResponse.connectionId === null)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , this.getNegotiationResponse(url)];\n\n          case 4:\n            negotiateResponse = _a.sent();\n            connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this.transport.connect(connectUrl, requestedTransferFormat)];\n\n          case 6:\n            _a.sent();\n\n            this.changeState(0\n            /* Connecting */\n            , 1\n            /* Connected */\n            );\n            return [2\n            /*return*/\n            ];\n\n          case 7:\n            ex_1 = _a.sent();\n            this.logger.log(LogLevel.Error, \"Failed to start the transport '\" + HttpTransportType[transport] + \"': \" + ex_1);\n            this.connectionState = 2\n            /* Disconnected */\n            ;\n            negotiateResponse.connectionId = null;\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            _i++;\n            return [3\n            /*break*/\n            , 3];\n\n          case 9:\n            throw new Error(\"Unable to initialize any of the available transports.\");\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.constructTransport = function (transport) {\n    switch (transport) {\n      case HttpTransportType.WebSockets:\n        return new WebSocketTransport(this.accessTokenFactory, this.logger, this.options.logMessageContent);\n\n      case HttpTransportType.ServerSentEvents:\n        return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent);\n\n      case HttpTransportType.LongPolling:\n        return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent);\n\n      default:\n        throw new Error(\"Unknown transport: \" + transport + \".\");\n    }\n  };\n\n  HttpConnection.prototype.resolveTransport = function (endpoint, requestedTransport, requestedTransferFormat) {\n    var transport = HttpTransportType[endpoint.transport];\n\n    if (transport === null || transport === undefined) {\n      this.logger.log(LogLevel.Debug, \"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\n    } else {\n      var transferFormats = endpoint.transferFormats.map(function (s) {\n        return TransferFormat[s];\n      });\n\n      if (transportMatches(requestedTransport, transport)) {\n        if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\n          if (transport === HttpTransportType.WebSockets && typeof WebSocket === \"undefined\" || transport === HttpTransportType.ServerSentEvents && typeof EventSource === \"undefined\") {\n            this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it is not supported in your environment.'\");\n          } else {\n            this.logger.log(LogLevel.Debug, \"Selecting transport '\" + HttpTransportType[transport] + \"'\");\n            return transport;\n          }\n        } else {\n          this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it does not support the requested transfer format '\" + TransferFormat[requestedTransferFormat] + \"'.\");\n        }\n      } else {\n        this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it was disabled by the client.\");\n      }\n    }\n\n    return null;\n  };\n\n  HttpConnection.prototype.isITransport = function (transport) {\n    return transport && typeof transport === \"object\" && \"connect\" in transport;\n  };\n\n  HttpConnection.prototype.changeState = function (from, to) {\n    if (this.connectionState === from) {\n      this.connectionState = to;\n      return true;\n    }\n\n    return false;\n  };\n\n  HttpConnection.prototype.stopConnection = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        this.transport = null; // If we have a stopError, it takes precedence over the error from the transport\n\n        error = this.stopError || error;\n\n        if (error) {\n          this.logger.log(LogLevel.Error, \"Connection disconnected with error '\" + error + \"'.\");\n        } else {\n          this.logger.log(LogLevel.Information, \"Connection disconnected.\");\n        }\n\n        this.connectionState = 2\n        /* Disconnected */\n        ;\n\n        if (this.onclose) {\n          this.onclose(error);\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  HttpConnection.prototype.resolveUrl = function (url) {\n    // startsWith is not supported in IE\n    if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\n      return url;\n    }\n\n    if (typeof window === \"undefined\" || !window || !window.document) {\n      throw new Error(\"Cannot resolve '\" + url + \"'.\");\n    } // Setting the url to the href propery of an anchor tag handles normalization\n    // for us. There are 3 main cases.\n    // 1. Relative  path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\n    // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\n    // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\n\n\n    var aTag = window.document.createElement(\"a\");\n    aTag.href = url;\n    this.logger.log(LogLevel.Information, \"Normalizing '\" + url + \"' to '\" + aTag.href + \"'.\");\n    return aTag.href;\n  };\n\n  HttpConnection.prototype.resolveNegotiateUrl = function (url) {\n    var index = url.indexOf(\"?\");\n    var negotiateUrl = url.substring(0, index === -1 ? url.length : index);\n\n    if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\n      negotiateUrl += \"/\";\n    }\n\n    negotiateUrl += \"negotiate\";\n    negotiateUrl += index === -1 ? \"\" : url.substring(index);\n    return negotiateUrl;\n  };\n\n  return HttpConnection;\n}();\n\nexport { HttpConnection };\n\nfunction transportMatches(requestedTransport, actualTransport) {\n  return !requestedTransport || (actualTransport & requestedTransport) !== 0;\n}","map":{"version":3,"mappings":"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","names":["DefaultHttpClient","LogLevel","HttpTransportType","TransferFormat","LongPollingTransport","ServerSentEventsTransport","Arg","createLogger","WebSocketTransport","MAX_REDIRECTS","url","options","isRequired","logger","baseUrl","resolveUrl","accessTokenFactory","logMessageContent","httpClient","connectionState","HttpConnection","transferFormat","Binary","isIn","log","Debug","Promise","reject","Error","startPromise","startInternal","data","transport","send","error","_a","stopError","stop","skipNegotiation","WebSockets","constructTransport","connect","negotiateResponse","redirects","this_1","getNegotiationResponse","accessToken","accessToken_1","createTransport","features","inherentKeepAlive","onreceive","onclose","e","stopConnection","changeState","e_2","token","_b","headers","negotiateUrl","resolveNegotiateUrl","post","content","response","statusCode","JSON","parse","e_3","connectionId","indexOf","requestedTransport","requestedTransferFormat","connectUrl","createConnectUrl","isITransport","transports","availableTransports","transports_1","_i","endpoint","resolveTransport","ex_1","ServerSentEvents","LongPolling","undefined","transferFormats","map","s","transportMatches","WebSocket","EventSource","from","to","Information","lastIndexOf","window","document","aTag","createElement","href","index","substring","length","actualTransport"],"sourceRoot":"","sources":["../../src/HttpConnection.ts"],"sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { DefaultHttpClient, HttpClient } from \"./HttpClient\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, ITransport, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\n\r\n/** @private */\r\nconst enum ConnectionState {\r\n    Connecting,\r\n    Connected,\r\n    Disconnected,\r\n}\r\n\r\n/** @private */\r\nexport interface INegotiateResponse {\r\n    connectionId?: string;\r\n    availableTransports?: IAvailableTransport[];\r\n    url?: string;\r\n    accessToken?: string;\r\n}\r\n\r\n/** @private */\r\nexport interface IAvailableTransport {\r\n    transport: keyof typeof HttpTransportType;\r\n    transferFormats: Array<keyof typeof TransferFormat>;\r\n}\r\n\r\nconst MAX_REDIRECTS = 100;\r\n\r\n/** @private */\r\nexport class HttpConnection implements IConnection {\r\n    private connectionState: ConnectionState;\r\n    private baseUrl: string;\r\n    private readonly httpClient: HttpClient;\r\n    private readonly logger: ILogger;\r\n    private readonly options: IHttpConnectionOptions;\r\n    private transport: ITransport;\r\n    private startPromise: Promise<void>;\r\n    private stopError?: Error;\r\n    private accessTokenFactory?: () => string | Promise<string>;\r\n\r\n    public readonly features: any = {};\r\n    public onreceive: (data: string | ArrayBuffer) => void;\r\n    public onclose: (e?: Error) => void;\r\n\r\n    constructor(url: string, options: IHttpConnectionOptions = {}) {\r\n        Arg.isRequired(url, \"url\");\r\n\r\n        this.logger = createLogger(options.logger);\r\n        this.baseUrl = this.resolveUrl(url);\r\n\r\n        options = options || {};\r\n        options.accessTokenFactory = options.accessTokenFactory || (() => null);\r\n        options.logMessageContent = options.logMessageContent || false;\r\n\r\n        this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);\r\n        this.connectionState = ConnectionState.Disconnected;\r\n        this.options = options;\r\n    }\r\n\r\n    public start(): Promise<void>;\r\n    public start(transferFormat: TransferFormat): Promise<void>;\r\n    public start(transferFormat?: TransferFormat): Promise<void> {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this.logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n\r\n        if (this.connectionState !== ConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a connection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this.connectionState = ConnectionState.Connecting;\r\n\r\n        this.startPromise = this.startInternal(transferFormat);\r\n        return this.startPromise;\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        if (this.connectionState !== ConnectionState.Connected) {\r\n            throw new Error(\"Cannot send data if the connection is not in the 'Connected' State.\");\r\n        }\r\n\r\n        return this.transport.send(data);\r\n    }\r\n\r\n    public async stop(error?: Error): Promise<void> {\r\n        this.connectionState = ConnectionState.Disconnected;\r\n\r\n        try {\r\n            await this.startPromise;\r\n        } catch (e) {\r\n            // this exception is returned to the user as a rejected Promise from the start method\r\n        }\r\n\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        if (this.transport) {\r\n            this.stopError = error;\r\n            await this.transport.stop();\r\n            this.transport = null;\r\n        }\r\n    }\r\n\r\n    private async startInternal(transferFormat: TransferFormat): Promise<void> {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this.accessTokenFactory = this.options.accessTokenFactory;\r\n\r\n        try {\r\n            if (this.options.skipNegotiation) {\r\n                if (this.options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this.constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this.transport.connect(url, transferFormat);\r\n                } else {\r\n                    throw Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            } else {\r\n                let negotiateResponse: INegotiateResponse = null;\r\n                let redirects = 0;\r\n\r\n                do {\r\n                    negotiateResponse = await this.getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this.connectionState === ConnectionState.Disconnected) {\r\n                        return;\r\n                    }\r\n\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this.accessTokenFactory = () => accessToken;\r\n                    }\r\n\r\n                    redirects++;\r\n                }\r\n                while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n\r\n                await this.createTransport(url, this.options.transport, negotiateResponse, transferFormat);\r\n            }\r\n\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n\r\n            this.transport.onreceive = this.onreceive;\r\n            this.transport.onclose = (e) => this.stopConnection(e);\r\n\r\n            // only change the state if we were connecting to not overwrite\r\n            // the state if the connection is already marked as Disconnected\r\n            this.changeState(ConnectionState.Connecting, ConnectionState.Connected);\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this.connectionState = ConnectionState.Disconnected;\r\n            this.transport = null;\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private async getNegotiationResponse(url: string): Promise<INegotiateResponse> {\r\n        const token = await this.accessTokenFactory();\r\n        let headers;\r\n        if (token) {\r\n            headers = {\r\n                [\"Authorization\"]: `Bearer ${token}`,\r\n            };\r\n        }\r\n\r\n        const negotiateUrl = this.resolveNegotiateUrl(url);\r\n        this.logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}`);\r\n        try {\r\n            const response = await this.httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers,\r\n            });\r\n\r\n            if (response.statusCode !== 200) {\r\n                throw Error(`Unexpected status code returned from negotiate ${response.statusCode}`);\r\n            }\r\n\r\n            return JSON.parse(response.content as string) as INegotiateResponse;\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private createConnectUrl(url: string, connectionId: string) {\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionId}`;\r\n    }\r\n\r\n    private async createTransport(url: string, requestedTransport: HttpTransportType | ITransport, negotiateResponse: INegotiateResponse, requestedTransferFormat: TransferFormat): Promise<void> {\r\n        let connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);\r\n        if (this.isITransport(requestedTransport)) {\r\n            this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this.transport.connect(connectUrl, requestedTransferFormat);\r\n\r\n            // only change the state if we were connecting to not overwrite\r\n            // the state if the connection is already marked as Disconnected\r\n            this.changeState(ConnectionState.Connecting, ConnectionState.Connected);\r\n            return;\r\n        }\r\n\r\n        const transports = negotiateResponse.availableTransports;\r\n        for (const endpoint of transports) {\r\n            this.connectionState = ConnectionState.Connecting;\r\n            const transport = this.resolveTransport(endpoint, requestedTransport, requestedTransferFormat);\r\n            if (typeof transport === \"number\") {\r\n                this.transport = this.constructTransport(transport);\r\n                if (negotiateResponse.connectionId === null) {\r\n                    negotiateResponse = await this.getNegotiationResponse(url);\r\n                    connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);\r\n                }\r\n                try {\r\n                    await this.transport.connect(connectUrl, requestedTransferFormat);\r\n                    this.changeState(ConnectionState.Connecting, ConnectionState.Connected);\r\n                    return;\r\n                } catch (ex) {\r\n                    this.logger.log(LogLevel.Error, `Failed to start the transport '${HttpTransportType[transport]}': ${ex}`);\r\n                    this.connectionState = ConnectionState.Disconnected;\r\n                    negotiateResponse.connectionId = null;\r\n                }\r\n            }\r\n        }\r\n\r\n        throw new Error(\"Unable to initialize any of the available transports.\");\r\n    }\r\n\r\n    private constructTransport(transport: HttpTransportType) {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                return new WebSocketTransport(this.accessTokenFactory, this.logger, this.options.logMessageContent);\r\n            case HttpTransportType.ServerSentEvents:\r\n                return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent);\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent);\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n\r\n    private resolveTransport(endpoint: IAvailableTransport, requestedTransport: HttpTransportType, requestedTransferFormat: TransferFormat): HttpTransportType | null {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this.logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        } else {\r\n            const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && typeof WebSocket === \"undefined\") ||\r\n                        (transport === HttpTransportType.ServerSentEvents && typeof EventSource === \"undefined\")) {\r\n                        this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                    } else {\r\n                        this.logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'`);\r\n                        return transport;\r\n                    }\r\n                } else {\r\n                    this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                }\r\n            } else {\r\n                this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private isITransport(transport: any): transport is ITransport {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n\r\n    private changeState(from: ConnectionState, to: ConnectionState): boolean {\r\n        if (this.connectionState === from) {\r\n            this.connectionState = to;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private async stopConnection(error?: Error): Promise<void> {\r\n        this.transport = null;\r\n\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this.stopError || error;\r\n\r\n        if (error) {\r\n            this.logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        } else {\r\n            this.logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n\r\n        this.connectionState = ConnectionState.Disconnected;\r\n\r\n        if (this.onclose) {\r\n            this.onclose(error);\r\n        }\r\n    }\r\n\r\n    private resolveUrl(url: string): string {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n\r\n        if (typeof window === \"undefined\" || !window || !window.document) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative  path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n\r\n        this.logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n\r\n    private resolveNegotiateUrl(url: string): string {\r\n        const index = url.indexOf(\"?\");\r\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n        return negotiateUrl;\r\n    }\r\n}\r\n\r\nfunction transportMatches(requestedTransport: HttpTransportType, actualTransport: HttpTransportType) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}