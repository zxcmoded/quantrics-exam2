{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\nimport { LogLevel } from \"./ILogger\";\nimport { isArrayBuffer } from \"./Utils\";\nvar requestModule;\n\nif (typeof XMLHttpRequest === \"undefined\") {\n  // In order to ignore the dynamic require in webpack builds we need to do this magic\n  // @ts-ignore: TS doesn't know about these names\n  var requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\n  requestModule = requireFunc(\"request\");\n}\n/** @private */\n\n\nvar NodeHttpClient =\n/** @class */\nfunction (_super) {\n  __extends(NodeHttpClient, _super);\n\n  function NodeHttpClient(logger) {\n    var _this = _super.call(this) || this;\n\n    if (typeof requestModule === \"undefined\") {\n      throw new Error(\"The 'request' module could not be loaded.\");\n    }\n\n    _this.logger = logger;\n    _this.cookieJar = requestModule.jar();\n    _this.request = requestModule.defaults({\n      jar: _this.cookieJar\n    });\n    return _this;\n  }\n\n  NodeHttpClient.prototype.send = function (httpRequest) {\n    var _this = this; // Check that abort was not signaled before calling send\n\n\n    if (httpRequest.abortSignal) {\n      if (httpRequest.abortSignal.aborted) {\n        return Promise.reject(new AbortError());\n      }\n    }\n\n    return new Promise(function (resolve, reject) {\n      var requestBody;\n\n      if (isArrayBuffer(httpRequest.content)) {\n        requestBody = Buffer.from(httpRequest.content);\n      } else {\n        requestBody = httpRequest.content || \"\";\n      }\n\n      var currentRequest = _this.request(httpRequest.url, {\n        body: requestBody,\n        // If binary is expected 'null' should be used, otherwise for text 'utf8'\n        encoding: httpRequest.responseType === \"arraybuffer\" ? null : \"utf8\",\n        headers: __assign({\n          // Tell auth middleware to 401 instead of redirecting\n          \"X-Requested-With\": \"XMLHttpRequest\"\n        }, httpRequest.headers),\n        method: httpRequest.method,\n        timeout: httpRequest.timeout\n      }, function (error, response, body) {\n        if (httpRequest.abortSignal) {\n          httpRequest.abortSignal.onabort = null;\n        }\n\n        if (error) {\n          if (error.code === \"ETIMEDOUT\") {\n            _this.logger.log(LogLevel.Warning, \"Timeout from HTTP request.\");\n\n            reject(new TimeoutError());\n          }\n\n          _this.logger.log(LogLevel.Warning, \"Error from HTTP request. \" + error);\n\n          reject(error);\n          return;\n        }\n\n        if (response.statusCode >= 200 && response.statusCode < 300) {\n          resolve(new HttpResponse(response.statusCode, response.statusMessage || \"\", body));\n        } else {\n          reject(new HttpError(response.statusMessage || \"\", response.statusCode || 0));\n        }\n      });\n\n      if (httpRequest.abortSignal) {\n        httpRequest.abortSignal.onabort = function () {\n          currentRequest.abort();\n          reject(new AbortError());\n        };\n      }\n    });\n  };\n\n  NodeHttpClient.prototype.getCookieString = function (url) {\n    return this.cookieJar.getCookieString(url);\n  };\n\n  return NodeHttpClient;\n}(HttpClient);\n\nexport { NodeHttpClient };","map":{"version":3,"mappings":"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","names":["AbortError","HttpError","TimeoutError","HttpClient","HttpResponse","LogLevel","isArrayBuffer","requestModule","XMLHttpRequest","requireFunc","__webpack_require__","__non_webpack_require__","require","__extends","logger","_super","Error","_this","cookieJar","jar","request","defaults","NodeHttpClient","httpRequest","abortSignal","aborted","Promise","reject","resolve","requestBody","content","Buffer","from","currentRequest","url","body","encoding","responseType","headers","method","timeout","error","response","onabort","code","log","Warning","statusCode","statusMessage","abort","getCookieString"],"sourceRoot":"","sources":["../../src/NodeHttpClient.ts"],"sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// @ts-ignore: This will be removed from built files and is here to make the types available during dev work\r\nimport * as Request from \"@types/request\";\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n\r\nlet requestModule: Request.RequestAPI<Request.Request, Request.CoreOptions, Request.RequiredUriUrl>;\r\nif (typeof XMLHttpRequest === \"undefined\") {\r\n    // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n    // @ts-ignore: TS doesn't know about these names\r\n    const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n    requestModule = requireFunc(\"request\");\r\n}\r\n\r\n/** @private */\r\nexport class NodeHttpClient extends HttpClient {\r\n    private readonly logger: ILogger;\r\n    private readonly request: typeof requestModule;\r\n    private readonly cookieJar: Request.CookieJar;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        if (typeof requestModule === \"undefined\") {\r\n            throw new Error(\"The 'request' module could not be loaded.\");\r\n        }\r\n\r\n        this.logger = logger;\r\n        this.cookieJar = requestModule.jar();\r\n        this.request = requestModule.defaults({ jar: this.cookieJar });\r\n    }\r\n\r\n    public send(httpRequest: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (httpRequest.abortSignal) {\r\n            if (httpRequest.abortSignal.aborted) {\r\n                return Promise.reject(new AbortError());\r\n            }\r\n        }\r\n\r\n        return new Promise<HttpResponse>((resolve, reject) => {\r\n\r\n            let requestBody: Buffer | string;\r\n            if (isArrayBuffer(httpRequest.content)) {\r\n                requestBody = Buffer.from(httpRequest.content);\r\n            } else {\r\n                requestBody = httpRequest.content || \"\";\r\n            }\r\n\r\n            const currentRequest = this.request(httpRequest.url!, {\r\n                body: requestBody,\r\n                // If binary is expected 'null' should be used, otherwise for text 'utf8'\r\n                encoding: httpRequest.responseType === \"arraybuffer\" ? null : \"utf8\",\r\n                headers: {\r\n                    // Tell auth middleware to 401 instead of redirecting\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...httpRequest.headers,\r\n                },\r\n                method: httpRequest.method,\r\n                timeout: httpRequest.timeout,\r\n            },\r\n            (error, response, body) => {\r\n                if (httpRequest.abortSignal) {\r\n                    httpRequest.abortSignal.onabort = null;\r\n                }\r\n\r\n                if (error) {\r\n                    if (error.code === \"ETIMEDOUT\") {\r\n                        this.logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                        reject(new TimeoutError());\r\n                    }\r\n                    this.logger.log(LogLevel.Warning, `Error from HTTP request. ${error}`);\r\n                    reject(error);\r\n                    return;\r\n                }\r\n\r\n                if (response.statusCode >= 200 && response.statusCode < 300) {\r\n                    resolve(new HttpResponse(response.statusCode, response.statusMessage || \"\", body));\r\n                } else {\r\n                    reject(new HttpError(response.statusMessage || \"\", response.statusCode || 0));\r\n                }\r\n            });\r\n\r\n            if (httpRequest.abortSignal) {\r\n                httpRequest.abortSignal.onabort = () => {\r\n                    currentRequest.abort();\r\n                    reject(new AbortError());\r\n                };\r\n            }\r\n        });\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        return this.cookieJar.getCookieString(url);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}