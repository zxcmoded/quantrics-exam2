{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/esnext.typed-array.find-last.js\";\nimport \"core-js/modules/esnext.typed-array.find-last-index.js\";\n\n// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\nimport { LogLevel } from \"./ILogger\";\nimport { HttpTransportType, TransferFormat } from \"./ITransport\";\nimport { LongPollingTransport } from \"./LongPollingTransport\";\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\nimport { Arg, createLogger, Platform } from \"./Utils\";\nimport { WebSocketTransport } from \"./WebSocketTransport\";\nvar MAX_REDIRECTS = 100;\nvar WebSocketModule = null;\nvar EventSourceModule = null;\n\nif (Platform.isNode && typeof require !== \"undefined\") {\n  // In order to ignore the dynamic require in webpack builds we need to do this magic\n  // @ts-ignore: TS doesn't know about these names\n  var requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\n  WebSocketModule = requireFunc(\"ws\");\n  EventSourceModule = requireFunc(\"eventsource\");\n}\n/** @private */\n\n\nvar HttpConnection =\n/** @class */\nfunction () {\n  function HttpConnection(url, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.stopPromiseResolver = function () {};\n\n    this.features = {};\n    this.negotiateVersion = 1;\n    Arg.isRequired(url, \"url\");\n    this.logger = createLogger(options.logger);\n    this.baseUrl = this.resolveUrl(url);\n    options = options || {};\n    options.logMessageContent = options.logMessageContent || false;\n\n    if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\n      options.WebSocket = WebSocket;\n    } else if (Platform.isNode && !options.WebSocket) {\n      if (WebSocketModule) {\n        options.WebSocket = WebSocketModule;\n      }\n    }\n\n    if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\n      options.EventSource = EventSource;\n    } else if (Platform.isNode && !options.EventSource) {\n      if (typeof EventSourceModule !== \"undefined\") {\n        options.EventSource = EventSourceModule;\n      }\n    }\n\n    this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);\n    this.connectionState = \"Disconnected\"\n    /* Disconnected */\n    ;\n    this.connectionStarted = false;\n    this.options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n\n  HttpConnection.prototype.start = function (transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var message, message;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            transferFormat = transferFormat || TransferFormat.Binary;\n            Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n            this.logger.log(LogLevel.Debug, \"Starting connection with transfer format '\" + TransferFormat[transferFormat] + \"'.\");\n\n            if (this.connectionState !== \"Disconnected\"\n            /* Disconnected */\n            ) {\n              return [2\n              /*return*/\n              , Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"))];\n            }\n\n            this.connectionState = \"Connecting \"\n            /* Connecting */\n            ;\n            this.startInternalPromise = this.startInternal(transferFormat);\n            return [4\n            /*yield*/\n            , this.startInternalPromise];\n\n          case 1:\n            _a.sent();\n\n            if (!(this.connectionState === \"Disconnecting\"\n            /* Disconnecting */\n            )) return [3\n            /*break*/\n            , 3];\n            message = \"Failed to start the HttpConnection before stop() was called.\";\n            this.logger.log(LogLevel.Error, message); // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n\n            return [4\n            /*yield*/\n            , this.stopPromise];\n\n          case 2:\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n            _a.sent();\n\n            return [2\n            /*return*/\n            , Promise.reject(new Error(message))];\n\n          case 3:\n            if (this.connectionState !== \"Connected\"\n            /* Connected */\n            ) {\n              message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n              this.logger.log(LogLevel.Error, message);\n              return [2\n              /*return*/\n              , Promise.reject(new Error(message))];\n            }\n\n            _a.label = 4;\n\n          case 4:\n            this.connectionStarted = true;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.send = function (data) {\n    if (this.connectionState !== \"Connected\"\n    /* Connected */\n    ) {\n      return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\n    }\n\n    if (!this.sendQueue) {\n      this.sendQueue = new TransportSendQueue(this.transport);\n    } // Transport will not be null if state is connected\n\n\n    return this.sendQueue.send(data);\n  };\n\n  HttpConnection.prototype.stop = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.connectionState === \"Disconnected\"\n            /* Disconnected */\n            ) {\n              this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnected state.\");\n              return [2\n              /*return*/\n              , Promise.resolve()];\n            }\n\n            if (this.connectionState === \"Disconnecting\"\n            /* Disconnecting */\n            ) {\n              this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\n              return [2\n              /*return*/\n              , this.stopPromise];\n            }\n\n            this.connectionState = \"Disconnecting\"\n            /* Disconnecting */\n            ;\n            this.stopPromise = new Promise(function (resolve) {\n              // Don't complete stop() until stopConnection() completes.\n              _this.stopPromiseResolver = resolve;\n            }); // stopInternal should never throw so just observe it.\n\n            return [4\n            /*yield*/\n            , this.stopInternal(error)];\n\n          case 1:\n            // stopInternal should never throw so just observe it.\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.stopPromise];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.stopInternal = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Set error as soon as possible otherwise there is a race between\n            // the transport closing and providing an error and the error from a close message\n            // We would prefer the close message error.\n            this.stopError = error;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.startInternalPromise];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            if (!this.transport) return [3\n            /*break*/\n            , 9];\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this.transport.stop()];\n\n          case 6:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            e_2 = _a.sent();\n            this.logger.log(LogLevel.Error, \"HttpConnection.transport.stop() threw error '\" + e_2 + \"'.\");\n            this.stopConnection();\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            this.transport = undefined;\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            this.logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n            _a.label = 10;\n\n          case 10:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.startInternal = function (transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var url, negotiateResponse, redirects, _loop_1, this_1, e_3;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            url = this.baseUrl;\n            this.accessTokenFactory = this.options.accessTokenFactory;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 12,, 13]);\n\n            if (!this.options.skipNegotiation) return [3\n            /*break*/\n            , 5];\n            if (!(this.options.transport === HttpTransportType.WebSockets)) return [3\n            /*break*/\n            , 3]; // No need to add a connection ID in this case\n\n            this.transport = this.constructTransport(HttpTransportType.WebSockets); // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n\n            return [4\n            /*yield*/\n            , this.startTransport(url, transferFormat)];\n\n          case 2:\n            // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n\n          case 4:\n            return [3\n            /*break*/\n            , 11];\n\n          case 5:\n            negotiateResponse = null;\n            redirects = 0;\n\n            _loop_1 = function () {\n              var accessToken_1;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4\n                    /*yield*/\n                    , this_1.getNegotiationResponse(url)];\n\n                  case 1:\n                    negotiateResponse = _a.sent(); // the user tries to stop the connection when it is being started\n\n                    if (this_1.connectionState === \"Disconnecting\"\n                    /* Disconnecting */\n                    || this_1.connectionState === \"Disconnected\"\n                    /* Disconnected */\n                    ) {\n                      throw new Error(\"The connection was stopped during negotiation.\");\n                    }\n\n                    if (negotiateResponse.error) {\n                      throw new Error(negotiateResponse.error);\n                    }\n\n                    if (negotiateResponse.ProtocolVersion) {\n                      throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n                    }\n\n                    if (negotiateResponse.url) {\n                      url = negotiateResponse.url;\n                    }\n\n                    if (negotiateResponse.accessToken) {\n                      accessToken_1 = negotiateResponse.accessToken;\n\n                      this_1.accessTokenFactory = function () {\n                        return accessToken_1;\n                      };\n                    }\n\n                    redirects++;\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            };\n\n            this_1 = this;\n            _a.label = 6;\n\n          case 6:\n            return [5\n            /*yield**/\n            , _loop_1()];\n\n          case 7:\n            _a.sent();\n\n            _a.label = 8;\n\n          case 8:\n            if (negotiateResponse.url && redirects < MAX_REDIRECTS) return [3\n            /*break*/\n            , 6];\n            _a.label = 9;\n\n          case 9:\n            if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\n              throw new Error(\"Negotiate redirection limit exceeded.\");\n            }\n\n            return [4\n            /*yield*/\n            , this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];\n\n          case 10:\n            _a.sent();\n\n            _a.label = 11;\n\n          case 11:\n            if (this.transport instanceof LongPollingTransport) {\n              this.features.inherentKeepAlive = true;\n            }\n\n            if (this.connectionState === \"Connecting \"\n            /* Connecting */\n            ) {\n              // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\n              // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\n              this.logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\n              this.connectionState = \"Connected\"\n              /* Connected */\n              ;\n            }\n\n            return [3\n            /*break*/\n            , 13];\n\n          case 12:\n            e_3 = _a.sent();\n            this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e_3);\n            this.connectionState = \"Disconnected\"\n            /* Disconnected */\n            ;\n            this.transport = undefined; // if start fails, any active calls to stop assume that start will complete the stop promise\n\n            this.stopPromiseResolver();\n            return [2\n            /*return*/\n            , Promise.reject(e_3)];\n\n          case 13:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.getNegotiationResponse = function (url) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, headers, token, negotiateUrl, response, negotiateResponse, e_4;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!this.accessTokenFactory) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.accessTokenFactory()];\n\n          case 1:\n            token = _b.sent();\n\n            if (token) {\n              headers = (_a = {}, _a[\"Authorization\"] = \"Bearer \" + token, _a);\n            }\n\n            _b.label = 2;\n\n          case 2:\n            negotiateUrl = this.resolveNegotiateUrl(url);\n            this.logger.log(LogLevel.Debug, \"Sending negotiation request: \" + negotiateUrl + \".\");\n            _b.label = 3;\n\n          case 3:\n            _b.trys.push([3, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , this.httpClient.post(negotiateUrl, {\n              content: \"\",\n              headers: headers\n            })];\n\n          case 4:\n            response = _b.sent();\n\n            if (response.statusCode !== 200) {\n              return [2\n              /*return*/\n              , Promise.reject(new Error(\"Unexpected status code returned from negotiate \" + response.statusCode))];\n            }\n\n            negotiateResponse = JSON.parse(response.content);\n\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\n              // Negotiate version 0 doesn't use connectionToken\n              // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\n              negotiateResponse.connectionToken = negotiateResponse.connectionId;\n            }\n\n            return [2\n            /*return*/\n            , negotiateResponse];\n\n          case 5:\n            e_4 = _b.sent();\n            this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e_4);\n            return [2\n            /*return*/\n            , Promise.reject(e_4)];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.createConnectUrl = function (url, connectionToken) {\n    if (!connectionToken) {\n      return url;\n    }\n\n    return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + (\"id=\" + connectionToken);\n  };\n\n  HttpConnection.prototype.createTransport = function (url, requestedTransport, negotiateResponse, requestedTransferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var connectUrl, transportExceptions, transports, negotiate, _i, transports_1, endpoint, transportOrError, ex_1, ex_2, message;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);\n            if (!this.isITransport(requestedTransport)) return [3\n            /*break*/\n            , 2];\n            this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n            this.transport = requestedTransport;\n            return [4\n            /*yield*/\n            , this.startTransport(connectUrl, requestedTransferFormat)];\n\n          case 1:\n            _a.sent();\n\n            this.connectionId = negotiateResponse.connectionId;\n            return [2\n            /*return*/\n            ];\n\n          case 2:\n            transportExceptions = [];\n            transports = negotiateResponse.availableTransports || [];\n            negotiate = negotiateResponse;\n            _i = 0, transports_1 = transports;\n            _a.label = 3;\n\n          case 3:\n            if (!(_i < transports_1.length)) return [3\n            /*break*/\n            , 13];\n            endpoint = transports_1[_i];\n            transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\n            if (!(transportOrError instanceof Error)) return [3\n            /*break*/\n            , 4]; // Store the error and continue, we don't want to cause a re-negotiate in these cases\n\n            transportExceptions.push(endpoint.transport + \" failed: \" + transportOrError);\n            return [3\n            /*break*/\n            , 12];\n\n          case 4:\n            if (!this.isITransport(transportOrError)) return [3\n            /*break*/\n            , 12];\n            this.transport = transportOrError;\n            if (!!negotiate) return [3\n            /*break*/\n            , 9];\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this.getNegotiationResponse(url)];\n\n          case 6:\n            negotiate = _a.sent();\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            ex_1 = _a.sent();\n            return [2\n            /*return*/\n            , Promise.reject(ex_1)];\n\n          case 8:\n            connectUrl = this.createConnectUrl(url, negotiate.connectionToken);\n            _a.label = 9;\n\n          case 9:\n            _a.trys.push([9, 11,, 12]);\n\n            return [4\n            /*yield*/\n            , this.startTransport(connectUrl, requestedTransferFormat)];\n\n          case 10:\n            _a.sent();\n\n            this.connectionId = negotiate.connectionId;\n            return [2\n            /*return*/\n            ];\n\n          case 11:\n            ex_2 = _a.sent();\n            this.logger.log(LogLevel.Error, \"Failed to start the transport '\" + endpoint.transport + \"': \" + ex_2);\n            negotiate = undefined;\n            transportExceptions.push(endpoint.transport + \" failed: \" + ex_2);\n\n            if (this.connectionState !== \"Connecting \"\n            /* Connecting */\n            ) {\n              message = \"Failed to select transport before stop() was called.\";\n              this.logger.log(LogLevel.Debug, message);\n              return [2\n              /*return*/\n              , Promise.reject(new Error(message))];\n            }\n\n            return [3\n            /*break*/\n            , 12];\n\n          case 12:\n            _i++;\n            return [3\n            /*break*/\n            , 3];\n\n          case 13:\n            if (transportExceptions.length > 0) {\n              return [2\n              /*return*/\n              , Promise.reject(new Error(\"Unable to connect to the server with any of the available transports. \" + transportExceptions.join(\" \")))];\n            }\n\n            return [2\n            /*return*/\n            , Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"))];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.constructTransport = function (transport) {\n    switch (transport) {\n      case HttpTransportType.WebSockets:\n        if (!this.options.WebSocket) {\n          throw new Error(\"'WebSocket' is not supported in your environment.\");\n        }\n\n        return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket);\n\n      case HttpTransportType.ServerSentEvents:\n        if (!this.options.EventSource) {\n          throw new Error(\"'EventSource' is not supported in your environment.\");\n        }\n\n        return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource);\n\n      case HttpTransportType.LongPolling:\n        return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false);\n\n      default:\n        throw new Error(\"Unknown transport: \" + transport + \".\");\n    }\n  };\n\n  HttpConnection.prototype.startTransport = function (url, transferFormat) {\n    var _this = this;\n\n    this.transport.onreceive = this.onreceive;\n\n    this.transport.onclose = function (e) {\n      return _this.stopConnection(e);\n    };\n\n    return this.transport.connect(url, transferFormat);\n  };\n\n  HttpConnection.prototype.resolveTransportOrError = function (endpoint, requestedTransport, requestedTransferFormat) {\n    var transport = HttpTransportType[endpoint.transport];\n\n    if (transport === null || transport === undefined) {\n      this.logger.log(LogLevel.Debug, \"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\n      return new Error(\"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\n    } else {\n      if (transportMatches(requestedTransport, transport)) {\n        var transferFormats = endpoint.transferFormats.map(function (s) {\n          return TransferFormat[s];\n        });\n\n        if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\n          if (transport === HttpTransportType.WebSockets && !this.options.WebSocket || transport === HttpTransportType.ServerSentEvents && !this.options.EventSource) {\n            this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it is not supported in your environment.'\");\n            return new Error(\"'\" + HttpTransportType[transport] + \"' is not supported in your environment.\");\n          } else {\n            this.logger.log(LogLevel.Debug, \"Selecting transport '\" + HttpTransportType[transport] + \"'.\");\n\n            try {\n              return this.constructTransport(transport);\n            } catch (ex) {\n              return ex;\n            }\n          }\n        } else {\n          this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it does not support the requested transfer format '\" + TransferFormat[requestedTransferFormat] + \"'.\");\n          return new Error(\"'\" + HttpTransportType[transport] + \"' does not support \" + TransferFormat[requestedTransferFormat] + \".\");\n        }\n      } else {\n        this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it was disabled by the client.\");\n        return new Error(\"'\" + HttpTransportType[transport] + \"' is disabled by the client.\");\n      }\n    }\n  };\n\n  HttpConnection.prototype.isITransport = function (transport) {\n    return transport && typeof transport === \"object\" && \"connect\" in transport;\n  };\n\n  HttpConnection.prototype.stopConnection = function (error) {\n    var _this = this;\n\n    this.logger.log(LogLevel.Debug, \"HttpConnection.stopConnection(\" + error + \") called while in state \" + this.connectionState + \".\");\n    this.transport = undefined; // If we have a stopError, it takes precedence over the error from the transport\n\n    error = this.stopError || error;\n    this.stopError = undefined;\n\n    if (this.connectionState === \"Disconnected\"\n    /* Disconnected */\n    ) {\n      this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection is already in the disconnected state.\");\n      return;\n    }\n\n    if (this.connectionState === \"Connecting \"\n    /* Connecting */\n    ) {\n      this.logger.log(LogLevel.Warning, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection hasn't yet left the in the connecting state.\");\n      return;\n    }\n\n    if (this.connectionState === \"Disconnecting\"\n    /* Disconnecting */\n    ) {\n      // A call to stop() induced this call to stopConnection and needs to be completed.\n      // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\n      this.stopPromiseResolver();\n    }\n\n    if (error) {\n      this.logger.log(LogLevel.Error, \"Connection disconnected with error '\" + error + \"'.\");\n    } else {\n      this.logger.log(LogLevel.Information, \"Connection disconnected.\");\n    }\n\n    if (this.sendQueue) {\n      this.sendQueue.stop().catch(function (e) {\n        _this.logger.log(LogLevel.Error, \"TransportSendQueue.stop() threw error '\" + e + \"'.\");\n      });\n      this.sendQueue = undefined;\n    }\n\n    this.connectionId = undefined;\n    this.connectionState = \"Disconnected\"\n    /* Disconnected */\n    ;\n\n    if (this.connectionStarted) {\n      this.connectionStarted = false;\n\n      try {\n        if (this.onclose) {\n          this.onclose(error);\n        }\n      } catch (e) {\n        this.logger.log(LogLevel.Error, \"HttpConnection.onclose(\" + error + \") threw error '\" + e + \"'.\");\n      }\n    }\n  };\n\n  HttpConnection.prototype.resolveUrl = function (url) {\n    // startsWith is not supported in IE\n    if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\n      return url;\n    }\n\n    if (!Platform.isBrowser || !window.document) {\n      throw new Error(\"Cannot resolve '\" + url + \"'.\");\n    } // Setting the url to the href propery of an anchor tag handles normalization\n    // for us. There are 3 main cases.\n    // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\n    // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\n    // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\n\n\n    var aTag = window.document.createElement(\"a\");\n    aTag.href = url;\n    this.logger.log(LogLevel.Information, \"Normalizing '\" + url + \"' to '\" + aTag.href + \"'.\");\n    return aTag.href;\n  };\n\n  HttpConnection.prototype.resolveNegotiateUrl = function (url) {\n    var index = url.indexOf(\"?\");\n    var negotiateUrl = url.substring(0, index === -1 ? url.length : index);\n\n    if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\n      negotiateUrl += \"/\";\n    }\n\n    negotiateUrl += \"negotiate\";\n    negotiateUrl += index === -1 ? \"\" : url.substring(index);\n\n    if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\n      negotiateUrl += index === -1 ? \"?\" : \"&\";\n      negotiateUrl += \"negotiateVersion=\" + this.negotiateVersion;\n    }\n\n    return negotiateUrl;\n  };\n\n  return HttpConnection;\n}();\n\nexport { HttpConnection };\n\nfunction transportMatches(requestedTransport, actualTransport) {\n  return !requestedTransport || (actualTransport & requestedTransport) !== 0;\n}\n/** @private */\n\n\nvar TransportSendQueue =\n/** @class */\nfunction () {\n  function TransportSendQueue(transport) {\n    this.transport = transport;\n    this.buffer = [];\n    this.executing = true;\n    this.sendBufferedData = new PromiseSource();\n    this.transportResult = new PromiseSource();\n    this.sendLoopPromise = this.sendLoop();\n  }\n\n  TransportSendQueue.prototype.send = function (data) {\n    this.bufferData(data);\n\n    if (!this.transportResult) {\n      this.transportResult = new PromiseSource();\n    }\n\n    return this.transportResult.promise;\n  };\n\n  TransportSendQueue.prototype.stop = function () {\n    this.executing = false;\n    this.sendBufferedData.resolve();\n    return this.sendLoopPromise;\n  };\n\n  TransportSendQueue.prototype.bufferData = function (data) {\n    if (this.buffer.length && typeof this.buffer[0] !== typeof data) {\n      throw new Error(\"Expected data to be of type \" + typeof this.buffer + \" but was of type \" + typeof data);\n    }\n\n    this.buffer.push(data);\n    this.sendBufferedData.resolve();\n  };\n\n  TransportSendQueue.prototype.sendLoop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var transportResult, data, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!true) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this.sendBufferedData.promise];\n\n          case 1:\n            _a.sent();\n\n            if (!this.executing) {\n              if (this.transportResult) {\n                this.transportResult.reject(\"Connection stopped.\");\n              }\n\n              return [3\n              /*break*/\n              , 6];\n            }\n\n            this.sendBufferedData = new PromiseSource();\n            transportResult = this.transportResult;\n            this.transportResult = undefined;\n            data = typeof this.buffer[0] === \"string\" ? this.buffer.join(\"\") : TransportSendQueue.concatBuffers(this.buffer);\n            this.buffer.length = 0;\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.transport.send(data)];\n\n          case 3:\n            _a.sent();\n\n            transportResult.resolve();\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            error_1 = _a.sent();\n            transportResult.reject(error_1);\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [3\n            /*break*/\n            , 0];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  TransportSendQueue.concatBuffers = function (arrayBuffers) {\n    var totalLength = arrayBuffers.map(function (b) {\n      return b.byteLength;\n    }).reduce(function (a, b) {\n      return a + b;\n    });\n    var result = new Uint8Array(totalLength);\n    var offset = 0;\n\n    for (var _i = 0, arrayBuffers_1 = arrayBuffers; _i < arrayBuffers_1.length; _i++) {\n      var item = arrayBuffers_1[_i];\n      result.set(new Uint8Array(item), offset);\n      offset += item.byteLength;\n    }\n\n    return result;\n  };\n\n  return TransportSendQueue;\n}();\n\nexport { TransportSendQueue };\n\nvar PromiseSource =\n/** @class */\nfunction () {\n  function PromiseSource() {\n    var _this = this;\n\n    this.promise = new Promise(function (resolve, reject) {\n      var _a;\n\n      return _a = [resolve, reject], _this.resolver = _a[0], _this.rejecter = _a[1], _a;\n    });\n  }\n\n  PromiseSource.prototype.resolve = function () {\n    this.resolver();\n  };\n\n  PromiseSource.prototype.reject = function (reason) {\n    this.rejecter(reason);\n  };\n\n  return PromiseSource;\n}();","map":{"version":3,"mappings":"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","names":["DefaultHttpClient","LogLevel","HttpTransportType","TransferFormat","LongPollingTransport","ServerSentEventsTransport","Arg","createLogger","Platform","WebSocketTransport","MAX_REDIRECTS","WebSocketModule","EventSourceModule","isNode","require","requireFunc","__webpack_require__","__non_webpack_require__","url","options","isRequired","logger","baseUrl","resolveUrl","logMessageContent","WebSocket","EventSource","httpClient","connectionState","connectionStarted","onreceive","onclose","HttpConnection","transferFormat","Binary","isIn","log","Debug","Promise","reject","Error","startInternalPromise","startInternal","_a","message","stopPromise","data","sendQueue","TransportSendQueue","transport","send","error","resolve","_this","stopPromiseResolver","stopInternal","stopError","stop","e_2","stopConnection","undefined","accessTokenFactory","skipNegotiation","WebSockets","constructTransport","startTransport","negotiateResponse","redirects","this_1","getNegotiationResponse","ProtocolVersion","accessToken","accessToken_1","createTransport","features","inherentKeepAlive","e_3","token","_b","headers","negotiateUrl","resolveNegotiateUrl","post","content","response","statusCode","JSON","parse","negotiateVersion","connectionToken","connectionId","e_4","indexOf","requestedTransport","requestedTransferFormat","connectUrl","createConnectUrl","isITransport","transportExceptions","transports","availableTransports","negotiate","transports_1","_i","endpoint","transportOrError","resolveTransportOrError","push","ex_1","ex_2","length","join","ServerSentEvents","LongPolling","e","connect","transportMatches","transferFormats","map","s","ex","Warning","Information","catch","lastIndexOf","isBrowser","window","document","aTag","createElement","href","index","substring","actualTransport","sendBufferedData","PromiseSource","transportResult","sendLoopPromise","sendLoop","bufferData","promise","executing","buffer","concatBuffers","error_1","arrayBuffers","totalLength","b","byteLength","reduce","a","result","Uint8Array","offset","item","set","resolver","reason","rejecter"],"sourceRoot":"","sources":["../../src/HttpConnection.ts"],"sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, ITransport, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\n\r\n/** @private */\r\nconst enum ConnectionState {\r\n    Connecting = \"Connecting \",\r\n    Connected = \"Connected\",\r\n    Disconnected = \"Disconnected\",\r\n    Disconnecting = \"Disconnecting\",\r\n}\r\n\r\n/** @private */\r\nexport interface INegotiateResponse {\r\n    connectionId?: string;\r\n    connectionToken?: string;\r\n    negotiateVersion?: number;\r\n    availableTransports?: IAvailableTransport[];\r\n    url?: string;\r\n    accessToken?: string;\r\n    error?: string;\r\n}\r\n\r\n/** @private */\r\nexport interface IAvailableTransport {\r\n    transport: keyof typeof HttpTransportType;\r\n    transferFormats: Array<keyof typeof TransferFormat>;\r\n}\r\n\r\nconst MAX_REDIRECTS = 100;\r\n\r\nlet WebSocketModule: any = null;\r\nlet EventSourceModule: any = null;\r\nif (Platform.isNode && typeof require !== \"undefined\") {\r\n    // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n    // @ts-ignore: TS doesn't know about these names\r\n    const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n    WebSocketModule = requireFunc(\"ws\");\r\n    EventSourceModule = requireFunc(\"eventsource\");\r\n}\r\n\r\n/** @private */\r\nexport class HttpConnection implements IConnection {\r\n    private connectionState: ConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private connectionStarted: boolean;\r\n    private readonly httpClient: HttpClient;\r\n    private readonly logger: ILogger;\r\n    private readonly options: IHttpConnectionOptions;\r\n    private transport?: ITransport;\r\n    private startInternalPromise?: Promise<void>;\r\n    private stopPromise?: Promise<void>;\r\n    private stopPromiseResolver: (value?: PromiseLike<void>) => void = () => {};\r\n    private stopError?: Error;\r\n    private accessTokenFactory?: () => string | Promise<string>;\r\n    private sendQueue?: TransportSendQueue;\r\n\r\n    public readonly features: any = {};\r\n    public baseUrl: string;\r\n    public connectionId?: string;\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((e?: Error) => void) | null;\r\n\r\n    private readonly negotiateVersion: number = 1;\r\n\r\n    constructor(url: string, options: IHttpConnectionOptions = {}) {\r\n        Arg.isRequired(url, \"url\");\r\n\r\n        this.logger = createLogger(options.logger);\r\n        this.baseUrl = this.resolveUrl(url);\r\n\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent || false;\r\n\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        } else if (Platform.isNode && !options.WebSocket) {\r\n            if (WebSocketModule) {\r\n                options.WebSocket = WebSocketModule;\r\n            }\r\n        }\r\n\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        } else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof EventSourceModule !== \"undefined\") {\r\n                options.EventSource = EventSourceModule;\r\n            }\r\n        }\r\n\r\n        this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);\r\n        this.connectionState = ConnectionState.Disconnected;\r\n        this.connectionStarted = false;\r\n        this.options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public start(): Promise<void>;\r\n    public start(transferFormat: TransferFormat): Promise<void>;\r\n    public async start(transferFormat?: TransferFormat): Promise<void> {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this.logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n\r\n        if (this.connectionState !== ConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this.connectionState = ConnectionState.Connecting;\r\n\r\n        this.startInternalPromise = this.startInternal(transferFormat);\r\n        await this.startInternalPromise;\r\n\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this.connectionState as any === ConnectionState.Disconnecting) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this.stopPromise;\r\n\r\n            return Promise.reject(new Error(message));\r\n        } else if (this.connectionState as any !== ConnectionState.Connected) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this.logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new Error(message));\r\n        }\r\n\r\n        this.connectionStarted = true;\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        if (this.connectionState !== ConnectionState.Connected) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n\r\n        if (!this.sendQueue) {\r\n            this.sendQueue = new TransportSendQueue(this.transport!);\r\n        }\r\n\r\n        // Transport will not be null if state is connected\r\n        return this.sendQueue.send(data);\r\n    }\r\n\r\n    public async stop(error?: Error): Promise<void> {\r\n        if (this.connectionState === ConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Disconnecting) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this.stopPromise;\r\n        }\r\n\r\n        this.connectionState = ConnectionState.Disconnecting;\r\n\r\n        this.stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this.stopPromiseResolver = resolve;\r\n        });\r\n\r\n        // stopInternal should never throw so just observe it.\r\n        await this.stopInternal(error);\r\n        await this.stopPromise;\r\n    }\r\n\r\n    private async stopInternal(error?: Error): Promise<void> {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this.stopError = error;\r\n\r\n        try {\r\n            await this.startInternalPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this.stopConnection();\r\n            }\r\n\r\n            this.transport = undefined;\r\n        } else {\r\n            this.logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n        }\r\n    }\r\n\r\n    private async startInternal(transferFormat: TransferFormat): Promise<void> {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this.accessTokenFactory = this.options.accessTokenFactory;\r\n\r\n        try {\r\n            if (this.options.skipNegotiation) {\r\n                if (this.options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this.constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this.startTransport(url, transferFormat);\r\n                } else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            } else {\r\n                let negotiateResponse: INegotiateResponse | null = null;\r\n                let redirects = 0;\r\n\r\n                do {\r\n                    negotiateResponse = await this.getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this.connectionState === ConnectionState.Disconnecting || this.connectionState === ConnectionState.Disconnected) {\r\n                        throw new Error(\"The connection was stopped during negotiation.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n\r\n                    if ((negotiateResponse as any).ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this.accessTokenFactory = () => accessToken;\r\n                    }\r\n\r\n                    redirects++;\r\n                }\r\n                while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n\r\n                await this.createTransport(url, this.options.transport, negotiateResponse, transferFormat);\r\n            }\r\n\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n\r\n            if (this.connectionState === ConnectionState.Connecting) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this.logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this.connectionState = ConnectionState.Connected;\r\n            }\r\n\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this.connectionState = ConnectionState.Disconnected;\r\n            this.transport = undefined;\r\n\r\n            // if start fails, any active calls to stop assume that start will complete the stop promise\r\n            this.stopPromiseResolver();\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async getNegotiationResponse(url: string): Promise<INegotiateResponse> {\r\n        let headers;\r\n        if (this.accessTokenFactory) {\r\n            const token = await this.accessTokenFactory();\r\n            if (token) {\r\n                headers = {\r\n                    [\"Authorization\"]: `Bearer ${token}`,\r\n                };\r\n            }\r\n        }\r\n\r\n        const negotiateUrl = this.resolveNegotiateUrl(url);\r\n        this.logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this.httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers,\r\n            });\r\n\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate ${response.statusCode}`));\r\n            }\r\n\r\n            const negotiateResponse = JSON.parse(response.content as string) as INegotiateResponse;\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n            return negotiateResponse;\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private createConnectUrl(url: string, connectionToken: string | null | undefined) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n\r\n    private async createTransport(url: string, requestedTransport: HttpTransportType | ITransport | undefined, negotiateResponse: INegotiateResponse, requestedTransferFormat: TransferFormat): Promise<void> {\r\n        let connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this.isITransport(requestedTransport)) {\r\n            this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this.startTransport(connectUrl, requestedTransferFormat);\r\n\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n\r\n        const transportExceptions: any[] = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate: INegotiateResponse | undefined = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed: ${transportOrError}`);\r\n            } else if (this.isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this.getNegotiationResponse(url);\r\n                    } catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this.createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this.startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                } catch (ex) {\r\n                    this.logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(`${endpoint.transport} failed: ${ex}`);\r\n\r\n                    if (this.connectionState !== ConnectionState.Connecting) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this.logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new Error(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new Error(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n\r\n    private constructTransport(transport: HttpTransportType): ITransport {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this.options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket);\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this.options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource);\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false);\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n\r\n    private startTransport(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        this.transport!.onreceive = this.onreceive;\r\n        this.transport!.onclose = (e) => this.stopConnection(e);\r\n        return this.transport!.connect(url, transferFormat);\r\n    }\r\n\r\n    private resolveTransportOrError(endpoint: IAvailableTransport, requestedTransport: HttpTransportType | undefined, requestedTransferFormat: TransferFormat): ITransport | Error {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this.logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        } else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this.options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this.options.EventSource)) {\r\n                        this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new Error(`'${HttpTransportType[transport]}' is not supported in your environment.`);\r\n                    } else {\r\n                        this.logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            return this.constructTransport(transport);\r\n                        } catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            } else {\r\n                this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new Error(`'${HttpTransportType[transport]}' is disabled by the client.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private isITransport(transport: any): transport is ITransport {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n\r\n    private stopConnection(error?: Error): void {\r\n        this.logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this.connectionState}.`);\r\n\r\n        this.transport = undefined;\r\n\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this.stopError || error;\r\n        this.stopError = undefined;\r\n\r\n        if (this.connectionState === ConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Connecting) {\r\n            this.logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection hasn't yet left the in the connecting state.`);\r\n            return;\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Disconnecting) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this.stopPromiseResolver();\r\n        }\r\n\r\n        if (error) {\r\n            this.logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        } else {\r\n            this.logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n\r\n        if (this.sendQueue) {\r\n            this.sendQueue.stop().catch((e) => {\r\n                this.logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this.sendQueue = undefined;\r\n        }\r\n\r\n        this.connectionId = undefined;\r\n        this.connectionState = ConnectionState.Disconnected;\r\n\r\n        if (this.connectionStarted) {\r\n            this.connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private resolveUrl(url: string): string {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n\r\n        if (!Platform.isBrowser || !window.document) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n\r\n        this.logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n\r\n    private resolveNegotiateUrl(url: string): string {\r\n        const index = url.indexOf(\"?\");\r\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n\r\n        if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\r\n            negotiateUrl += index === -1 ? \"?\" : \"&\";\r\n            negotiateUrl += \"negotiateVersion=\" + this.negotiateVersion;\r\n        }\r\n        return negotiateUrl;\r\n    }\r\n}\r\n\r\nfunction transportMatches(requestedTransport: HttpTransportType | undefined, actualTransport: HttpTransportType) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    private buffer: any[] = [];\r\n    private sendBufferedData: PromiseSource;\r\n    private executing: boolean = true;\r\n    private transportResult?: PromiseSource;\r\n    private sendLoopPromise: Promise<void>;\r\n\r\n    constructor(private readonly transport: ITransport) {\r\n        this.sendBufferedData = new PromiseSource();\r\n        this.transportResult = new PromiseSource();\r\n\r\n        this.sendLoopPromise = this.sendLoop();\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        this.bufferData(data);\r\n        if (!this.transportResult) {\r\n            this.transportResult = new PromiseSource();\r\n        }\r\n        return this.transportResult.promise;\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this.executing = false;\r\n        this.sendBufferedData.resolve();\r\n        return this.sendLoopPromise;\r\n    }\r\n\r\n    private bufferData(data: string | ArrayBuffer): void {\r\n        if (this.buffer.length && typeof(this.buffer[0]) !== typeof(data)) {\r\n            throw new Error(`Expected data to be of type ${typeof(this.buffer)} but was of type ${typeof(data)}`);\r\n        }\r\n\r\n        this.buffer.push(data);\r\n        this.sendBufferedData.resolve();\r\n    }\r\n\r\n    private async sendLoop(): Promise<void> {\r\n        while (true) {\r\n            await this.sendBufferedData.promise;\r\n\r\n            if (!this.executing) {\r\n                if (this.transportResult) {\r\n                    this.transportResult.reject(\"Connection stopped.\");\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            this.sendBufferedData = new PromiseSource();\r\n\r\n            const transportResult = this.transportResult!;\r\n            this.transportResult = undefined;\r\n\r\n            const data = typeof(this.buffer[0]) === \"string\" ?\r\n                this.buffer.join(\"\") :\r\n                TransportSendQueue.concatBuffers(this.buffer);\r\n\r\n            this.buffer.length = 0;\r\n\r\n            try {\r\n                await this.transport.send(data);\r\n                transportResult.resolve();\r\n            } catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static concatBuffers(arrayBuffers: ArrayBuffer[]): ArrayBuffer {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nclass PromiseSource {\r\n    private resolver?: () => void;\r\n    private rejecter!: (reason?: any) => void;\r\n    public promise: Promise<void>;\r\n\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this.resolver, this.rejecter] = [resolve, reject]);\r\n    }\r\n\r\n    public resolve(): void {\r\n        this.resolver!();\r\n    }\r\n\r\n    public reject(reason?: any): void {\r\n        this.rejecter!(reason);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}